# 自动对话历史记录功能设计计划

## 实现思路

设计一个自动化脚本/工具，能够：
1. 在每次对话结束时，自动在`memory.md`文件开头添加新的任务记录
2. 当记录数量超过50个时，自动删除最旧的记录以保持只保留最近50个记录
3. 保持文件格式的一致性和可读性

## 功能需求分析

### 核心功能
- **自动记录**：在每次任务完成时，自动生成标准化的任务记录并插入到文件开头
- **智能清理**：当记录数量超过阈值（50个记录）时，自动删除最旧的记录以保持只保留最近50个记录
- **格式保持**：确保所有记录遵循统一的Markdown格式

### 记录格式规范
```
## [序号]. [任务标题] ([日期])
- **任务内容**: [简要描述任务目标]
- **完成工作**: 
  - [具体完成的工作项1]
  - [具体完成的工作项2]
  - ...
- **关键成果**: [最重要的成果总结]
```

## 技术实现方案

### 方案一：Python脚本实现
创建一个独立的Python脚本，提供以下功能：

```python
# auto_memory_manager.py
import os
import re
from datetime import datetime
from typing import List, Dict

class MemoryManager:
    def __init__(self, memory_file_path: str = "memory.md", max_records: int = 50):
        self.memory_file_path = memory_file_path
        self.max_records = max_records
    
    def add_task_record(self, task_title: str, task_content: str, completed_work: List[str], key_achievements: str):
        """在文件开头添加新的任务记录"""
        # 生成新记录
        new_record = self._generate_task_record(task_title, task_content, completed_work, key_achievements)
        
        # 读取现有内容
        existing_content = self._read_existing_content()
        
        # 如果文件不存在或为空，创建标题
        if not existing_content.strip():
            full_content = "# 任务完成总结记录\n\n" + new_record
        else:
            # 移除可能存在的标题行，只保留记录部分
            lines = existing_content.split('\n')
            if lines and lines[0].strip() == "# 任务完成总结记录":
                content_without_title = '\n'.join(lines[2:])  # 跳过标题和空行
                full_content = "# 任务完成总结记录\n\n" + new_record + content_without_title
            else:
                full_content = "# 任务完成总结记录\n\n" + new_record + existing_content
        
        # 检查记录数量并清理
        final_content = self._manage_record_count(full_content)
        
        # 写入文件
        with open(self.memory_file_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
    
    def _generate_task_record(self, task_title: str, task_content: str, completed_work: List[str], key_achievements: str) -> str:
        """生成标准化的任务记录"""
        current_date = datetime.now().strftime("%Y-%m-%d")
        
        # 获取下一个序号
        next_number = self._get_next_task_number()
        
        record = f"## {next_number}. {task_title} ({current_date})\n"
        record += f"- **任务内容**: {task_content}\n"
        record += "- **完成工作**:\n"
        for work in completed_work:
            record += f"  - {work}\n"
        record += f"- **关键成果**: {key_achievements}\n\n"
        
        return record
    
    def _get_next_task_number(self) -> int:
        """获取下一个任务序号"""
        try:
            with open(self.memory_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 使用正则表达式匹配所有任务序号
            pattern = r'## (\d+)\.'
            matches = re.findall(pattern, content)
            if matches:
                numbers = [int(num) for num in matches]
                return max(numbers) + 1
            else:
                return 1
        except FileNotFoundError:
            return 1
    
    def _read_existing_content(self) -> str:
        """读取现有文件内容"""
        try:
            with open(self.memory_file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            return ""
    
    def _manage_record_count(self, content: str) -> str:
        """管理记录数量，超过阈值时删除最旧的记录"""
        lines = content.split('\n')
        
        # 找到所有任务记录的起始位置
        task_starts = []
        for i, line in enumerate(lines):
            if line.startswith('## ') and re.match(r'## \d+\.', line):
                task_starts.append(i)
        
        # 如果记录数量不超过阈值，直接返回
        if len(task_starts) <= self.max_records:
            return content
        
        # 计算需要删除的记录数量
        records_to_delete = len(task_starts) - self.max_records
        
        if records_to_delete <= 0:
            return content
        
        # 保留最新的max_records个记录
        # 任务记录按时间顺序排列，最新的在前面，最旧的在后面
        # 所以我们需要保留前max_records个记录的起始位置
        keep_starts = task_starts[:self.max_records]
        
        # 构建新的内容
        new_lines = []
        # 添加标题部分
        new_lines.extend(lines[:2])  # "# 任务完成总结记录\n\n"
        
        # 添加保留的记录
        for i, start_pos in enumerate(keep_starts):
            if i + 1 < len(keep_starts):
                next_start = keep_starts[i + 1]
                new_lines.extend(lines[start_pos:next_start])
            else:
                # 最后一个要保留的记录，添加到文件末尾
                new_lines.extend(lines[start_pos:])
        
        return '\n'.join(new_lines)
```

### 方案二：集成到现有工作流

修改现有的任务完成流程，在`attempt_completion`调用前自动调用记忆管理器：

```python
# 在Roo的工作流程中集成
def complete_task_with_memory(task_title, task_content, completed_work, key_achievements):
    # 先更新memory.md
    memory_manager = MemoryManager()
    memory_manager.add_task_record(task_title, task_content, completed_work, key_achievements)
    
    # 然后执行原有的任务完成逻辑
    attempt_completion(result="任务完成")
```

## 要修改的文件

1. **新建文件**: `Source/memory_manager/auto_memory_manager.py`
   - 实现完整的记忆管理功能
   - 包含详细的中文注释

2. **修改文件**: `Source/memory_manager/__init__.py` (如果需要)
   - 导出主要类和函数

3. **新建文件**: `Source/memory_manager/README.md`
   - 说明使用方法和API

4. **修改工作流**: 需要在Roo的主逻辑中集成此功能

## 取舍考量

### 优势
- **自动化程度高**: 完全自动处理记录和清理
- **格式标准化**: 确保所有记录格式一致
- **可维护性强**: 独立的模块化设计，易于维护和扩展
- **性能良好**: 只在必要时进行文件操作
- **基于记录数量的清理策略更符合实际需求**，避免了因记录长度不同导致的不一致问题

### 劣势
- **需要集成**: 需要修改Roo的主工作流程
- **复杂度增加**: 增加了额外的代码维护成本

### 替代方案考虑
- **简单脚本方案**: 直接使用shell脚本或批处理文件，但跨平台兼容性差
- **手动维护**: 继续手动维护，但违背了自动化需求
- **数据库方案**: 使用SQLite等轻量级数据库，但过度设计且增加了依赖

## 推荐方案
采用**方案一（Python脚本实现）**，因为：
1. 项目已经是Python为主的环境
2. 提供了良好的可扩展性和可维护性
3. 能够很好地处理复杂的文本解析和格式化需求
4. 易于集成到现有的Roo工作流程中
5. **基于记录数量的清理策略更符合实际需求**，避免了因记录长度不同导致的不一致问题

## 后续集成步骤
1. 实现核心MemoryManager类
2. 测试基本功能（添加记录、清理旧记录）
3. 集成到Roo的任务完成流程中
4. 添加错误处理和日志记录
5. 编写完整的测试用例